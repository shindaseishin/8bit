# 8bit - Simple computer simulator

## Description

This is a small project I started after watching Ben Eater's 8bit bread board computer build series on Youtube. I wanted to do something similar but my wife would not be happy about me going out and buying a bunch of electronics components for no good reason. So instead of trying to convince her to bless the purchases I figured the next best thing would be to write a simulator that scratches the same itch.

Good news is that I can work on the simulator on the bus ride to work.

So once that was settled I had to decide what to write it in. I originally wanted to write it in C++ with QT as an interface but decided to go a different direction. I've been wanting to learn Python and needed a interesting project to work on to go and learn it. Plus a part of me derived a strange pleasure in writing a hardware simulator in a language that was definitely not a good match for it. I knew it would be slow. That didn't bother me. After all I would be spending most of my time stepping through programs one microcode instruction at a time. Speed wasn't an issue. Also QT is available as a binding for Python so there's that. Actually, I've been wanting to learn a bit of ncurses programming. Hows'about I scrap the QT plan and replace it with ncurses. That sounds fun.

Alright so Python with ncurses. Now you know my thought process behind this.

# Usage

The simulator uses Python 3. With a bit of work it may run on 2 but I don't feel like doing that work. If it's important to you for some reason to get it running on 2, knock yourself out.

`python3 interface.py program.ram`

Currently the interface.py file is the main executable, but that will change soon. The program.ram is the file that contains the executable bytecode to execute.


## Architecture

So I tried to copy Ben's design with his different components all talking to each bother over a bus with control signals being generated by a instruction decoder. My original design was structured like that. In fact if you were to go back through the early commits you would find it. It kinda worked but was clunky and had a tendency to not work right. Main problem was the clock signal. It was often getting lost when the clock generated a new pulse while other components were still processing. See I had the clock on a timer sending out events. All the components would listen to that clock and when they heard a tick they would process their stuff. But the speed issue did raise it's head. So I went back to the drawing board ad reworked things a bit. I moved all the control functionality from the components into the instruction decoder and took the clock off of an event system. Now the clock will generate a pulse, trigger the instruction decoder, and then wait for that to finish before resetting it's timer. Works well now.

The system consists of the following components:

* Clock
    Regulates the actions of the computer. Generated clock on and clock off events. It currently only send that clock signal to the instruction decoder

* Data bus
    Acts as a place for components to put their data so that other components can pick it up.

* Address bus
    Controls the data being read/written by the ram. By latching a value into the address bus the memory module will automatically point itself to that byte in memory.

* Registers A & B
    Two general purpose registers.

* ALU
    Arithmetic Logic Unit. Does addition and subtraction on the values in Register A and B. Doing subtraction, B is always subtracted from A. Also tracks when an operation overflows and goes either above 255 on addition or below 0 on subtraction.

* Program counter
    Tracks the instruction to be executed. It actually holds the memory address of the next instruction to execute.

* Output
    Simple display to show integer numbers between 0 and 255.

* Memory
    Contains both the actual RAM (a whopping 256 bytes of it) and the instruction address registers

* Instruction decoder
    The fun part. This where all the magic happens. On low clock cycles the ID will take the current instruction and the microstep, look up it's control signals from the microcode and generate the control signals to be acted on on the next clock high pulse. On the high pulse it will look at each control signal and then act on which ones are active at a given moment. For example, if the /Counter Out/ and /Memory Address In/ signals are active it will take the current value from the Program Counter and puts it on the address bus. Then it tells the memory address register to latch in the value from the address bus.

* Help
    Just displays the keyboard commands to interact with the simulator.

## Assembler

A primitive assembler was added to allow users to write their programs in a simple assembly language and then convert the programs into executable programs for the computer. The assembler can deal with comments preceded with # either at the start of a line or following an Instruction.

The assembler will currently choke on a blank line. Also you can't declare variables. To use a variable you just need to put some data at a memory location and then remember the address to hard code it into the executable.

An instruction in the assembler follow the following structure:

`[Instruction] [operand]`

The instruction must be from the list below and the operand is optional for some instructions but when present must be a Python hex coded byte (such as 0x2A).

The following instructions are known to the assembler:

<table>
  <thead>
    <tr>
      <th>Instruction</th>
      <th>Name</th>
      <th>Operand</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <tr>NOOP</tr>
      <tr>No Operation</tr>
      <tr>N/A</tr>
      <tr>Basically just takes up space and everyone's valuable time</tr>
    </tr>
    <tr>
      <tr>LDA</tr>
      <tr>Load Register A from RAM</tr>
      <tr>Address to load value from</tr>
      <tr>Loads the value stored in the location pointed to by the operand into Register A</tr>
    </tr>
  </tbody>
</table>



## Todo (in no particular order)

* Improve the Assembler
    * Stop choking on blank lines
    * Be able to declare variables
* Resetting the computer does not update all components properly. Dos't affect execution but would be nice to whatever
* Have a proper main file that starts the interface rather than the interface being the main file.
* V2 rewrite to use PyQT
* V3 rewrite in C++ w/ QT

## License

This is licensed under the GPL v3 license. Do whatever you want with this as long as it is permitted under the GPL. Not really sure what you could possibly want to do with this. It's not that interesting.
